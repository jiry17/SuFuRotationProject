# Part2

在这一部分中，有一些开放性的思考问题 (用 * 标注，例如 **Q2.3***)。我们对这些问题没有强制的要求，简单思考，视自己的兴趣挑选 0~1 个问题深入探究即可。

### Task 0

请阅读 SuFu 论文 `SuFu.pdf` 的前三章，了解 SuFu 工具的运行原理。

### Task 1

在 Part1 Task1 中，我们为程序 `pos-prefix.f` 添加了 `Reframe` 标注并使用了 SuFu 对其进行优化。 

**Q1**: 尝试在这一程序上进一步添加 `rewrite`、`label`、与 `unlabel` 标注，并在 SuFu 的线上 Demo 中测试。注意在测试时，你需要取消 `AutoLabel` 选项以禁用 SuFu 的自动标注功能。

### Task 2

在 Part1 Task5 中，我们使用 SuFu 优化了 01 背包问题上的一个穷举程序，并得了一个可以在更快的时间内计算最大价值和的程序。

然而，在很多动态规划问题中，我们关心的并不是最优的目标值，而是最优目标值所对应的**方案**。文件 `01knapsack-with-plan.f` 中包含了一个修改后的穷举程序，其中 `getbest` 的返回值被修改为具有最大价值和的放置物品方案。

**Q2.1**: 在默认选项下（即仅勾选 `AutoLabel`）对该程序进行优化优化。优化是否能成功？如果成功，请比较这次的结果与 Part1 Task5 中的结果有何不同；如果失败，请简单分析原因。

**Q2.2**: 对 `01knapsack-with-plan.f` 进行修改，使得在不改变输出、不改变 SuFu 选项的情况下，SuFu 可以成功地进行优化。在这个过程中，请尽量使重构的规模最小。

**Q2.3***: 在 **Q2.2** 中你作出的手动修改是可以被自动化的吗？

### Task 3

阅读 SuFu 主页中的 Example 1: Rewrite using programs with non-scalar outputs 小节。

**Q3.1**: 为 `01knapsack-with-plan.f` 添加合适的 `rewrite`、`label`、与 `unlabel` 标注，并使用 SuFu 的 `NonScalar` 选项对其进行优化。

**Q3.2**: 回忆 SuFu 论文第 3 章中关于标注生成的描述。为什么这个标注生成算法与选项 `NonScalar` 无法兼容？

**Q3.3***: 能否扩展标注生成算法以解决 **Q3.2** 中的兼容性问题？

### Task 4

考虑一个简单的优化问题：给定一个 01 串，你需要从中选择一个子序列，满足子序列中不存在任何两个相邻的 1 ，并最大化子序列的长度。尽管这个问题可以用贪心的方法解决，在这里，让我们尝试将 Part1 Task5 中关于动态规划的处理方法应用过来。

**Q4.1**: 文件 `11-free-subsequence` 中包含着这个问题的一个穷举程序。请尝试为其添加合适的 `Reframe` 标注，使得 SuFu 能像 Part1 Task5 中那样，对该程序中的方案进行压缩。这个可以做到吗？如果你的答案是可以做到，则跳过这一任务中余下的三个问题。

**Q4.2**: 选择你觉得最合理的标注方式，对照 SuFu 论文第三章的标注算法，尝试还原 SuFu 的标注过程，并分析为什么 SuFu 无法产生满意的标注。

**Q4.3**: 请手动为穷举添加所有标注（即 `Reframe`, `label`, `unlabel`, 和 `rewrite`），使得 SuFu 可以在取消勾选 `AutoLabel` 的情况下完成优化。在这个过程中，你可以对穷举程序进行重构，但请尽量使重构的规模最小。

**Q4.4***: 对比 **Q4.3** 中你的手动标注与 SuFu 的标注算法，能否扩展标注生成算法使得 SuFu 能够自动产生你得到的手动标注？

### Task 5

这是一道最近的 [Coedeforces 比赛题](https://codeforces.com/contest/1937/problem/B)。 文件 `1937B.cpp` 中是这道题上用 C++ 编写的一个暴力程序（为了方便，此处省略原题中的多组数据并只输出方案数），其时间复杂度是 $O(n^2)$ 的。

**Q5.1**: 尝试将 `1937B.cpp` 翻译到 SuFu 的语言，并用 SuFu 将其优化到线性时间。为了方便，我在 `1937B.f` 中给出了一些基本数据结构和函数的定义。

**Q5.2***: 上述翻译过程的难点是什么？这个翻译可以做到自动化吗？

**Q5.3***: 考虑如果不进行翻译，而是直接把 SuFu 的算法迁移到 C++，那么 SuFu 算法中的哪些部分是可以直接迁移的，哪些部分又会出现问题？你有什么解决这些问题的想法吗？

